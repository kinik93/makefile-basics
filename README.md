# Introduction

Makefile is a standard language for defining a compilation and linking process.

Let's try to do a basic not-exhaustive tutorial to introduce makefiles and to learn about common operations we can do with them.

### Requirements
The make program is a requirement. Type `make -version` to see if you have it installed otherwise you can install it via `apt` on unix O.S. or through [choco](https://chocolatey.org/) on Windows O.S.

For this tutorial you will need also a C compiler like `gcc` or `clang` or whatever else you prefer.

## Tutorial
The first files we are going to write are the header [fakeHeader.h](https://github.com/kinik93/makefile-basics/blob/main/fakeHeader.h) where we put the prototype of our fake function
```c
#ifndef FAKEHEADER_H
#define FAKEHEADER_H 

void fakeFunction();

#endif
```
and the [fakeSource.c](https://github.com/kinik93/makefile-basics/blob/main/fakeSource.c) source file containing the definition of the function declared before in the fakeSuorce header
```c
#include "fakeHeader.h"
#include <stdio.h>

void fakeFunction(){
    printf("Hello from a useless function\n");
}
```
and finally we write a simple [main.c](https://github.com/kinik93/makefile-basics/blob/main/main.c) source file that invoke a function defined in the fakeHeader
```c
#include "fakeHeader.h"

int main(){
    fakeFunction();
}
```
You can compile the source files and produce the object files with 
```Bash
gcc -c main.c fakeSource.c -I.
```
and then link together to produce the executable "main" with 
```Bash
gcc -o main.o fakeSource.o -o main
```
Otherwise you can directly compile and link using gcc in a single line
```Bash
gcc main.c fakeSource.c -o main -I.
 ```

### Introducing makefile
A makefile is simply a file called makefile (or Makefile) with a set of *rules* with this structure:
```make
target … : prerequisites …
        recipe
        …
        …
```
* **Target** is usually the name of a file generated by a program or the name of an action that we want to do like *clean* or *install* for example.
* **Prerequisites** are a list of file separated by space required to create the target. A target depends usually on several files.
* **Recipe** is a list of one or more command that we want to execute to make the target. Each commands could be either on the same line or each separated by a newline. In this latter case every command must start with a TAB space. This behaviour can be modified changing the .RECIPEPREFIX variable.

Once you write your makefile you can open a shell in that folder and type ```make```.
This by default execute the first target which is called the *default goal*.
Otherwise you can type ```make target``` which execute a specific rule with that target.

The general synopsis of make command is the following 
```
make [options] [target1 target2 ...]
```

### Makefile for our tutorial
Based on the previous paragraph we can write a basic makefile for our C program:
```Bash
main: main.c fakeSource.c
	gcc main.c fakeSource.c -o main -I.

fakeSource.o: fakeSource.c fakeHeader.h
	gcc -c fakeSource.c

main.o: fakeSource.c
	gcc -c main.c

clean:
	rm *.o main
```

Typing ```make``` you execute the first rule getting the target *i.e.* the main executable.
The second and third rule instead create the object files.
Typing ```make clean``` all the object files .o and the main executable will be deleted.

You can also define your own variables to make the rules of the previous makefile a bit more generic
```Bash
CC=gcc
CFLAGS=-I.

main: main.c fakeSource.c
	$(CC) main.c fakeSource.c -o main $(CFLAGS)

fakeSource.o: fakeSource.c fakeHeader.h
	$(CC) -c fakeSource.c

main.o: main.c
	$(CC) -c main.c

clean:
	rm *.o main
```

A lot of further details can be found in the links of the [references](#references).

## Recap
In the end let's try to wrap up some pros and cons about makefile from a high point of view.

### What's good about makefile
* The make program checks whether target exists and if the prerequisite files of the target are up to date; if so, it avoids generating the target again
* A lot of libraries can be installed with few commands using make as tool. A common pattern to install an open source library could be the following:
```bash
make 
make install
```

Generally the `make` command build the library and the `make install` copy the headers of the library into `/usr/include` (or `/usr/local/include`), the dynamic libraries `.so` or static libraries `.a` into `usr/lib` (or `/usr/local/lib`) and the binaries into `usr/bin` (or `/usr/local/bin`). 
In that way after the installation of the library you can use it for example in your source code.

Sometimes you can also see `make -jN` which run N jobs (commands) in parallel at the same time speeding up the build process.
### What's not good about makefile
* Makefiles are O.S. dependent so you need to adapt them to different systems. Take a look to [CMake](https://cmake.org/) as a possible solution to solve this problem.
* Each command of each recipe must start with a tab space and that could be a real no-sense source of errors.
## References
Here I list some useful resources I used to increase my knowledge

* [A Simple Makefile Tutorial](https://cs.colby.edu/maxwell/courses/tutorials/maketutor/) - A very simple tutorial about the essentials of make and makefile
* [GNU make](https://www.gnu.org/software/make/manual/make.html) - The official documentation of make and makefile
* [Makefile Tutorial](https://github.com/vampy/Makefile) - A nice Github repository with a lot of examples about makefiles